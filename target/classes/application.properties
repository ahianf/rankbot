#spring.main.banner-mode=off
logging.level.org.springframework=ERROR
#
#spring.jpa.hibernate.ddl-auto=none
#
#spring.sql.init.platform=postgres
#spring.datasource.url=jdbc:postgresql://localhost:5432/testdb
#spring.datasource.username=app
#spring.datasource.password=password
##spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true
spring.datasource.url=jdbc:postgresql://localhost:5432/rankbot_db
spring.datasource.username=app
spring.datasource.password=passworder
#spring.jpa.show-sql=true

spring.cache.jcache.config=classpath:ehcache.xml

##Bucket4j

#enable/disable bucket4j support
#bucket4j.enabled=true
## the name of the cache key
#bucket4j.filters[0].cache-name=buckets
##[servlet,webflux,gateway]
#bucket4j.filters[0].filter-method=servlet
## Per default the lowest integer plus 10. Set it to a number higher then zero to execute it after e.g. Spring Security.
#bucket4j.filters[0].filter-order=1
## the json response which should be added to the body
#bucket4j.filters[0].http-response-body={ "message": "Too many requests" }
##bucket4j.filters[0].http-response-headers.<MY_CUSTOM_HEADER>=MY_CUSTOM_HEADER_VALUE # You can add any numbers of custom headers
## Hides response headers like x-rate-limit-remaining or x-rate-limit-retry-after-seconds on rate limiting
#bucket4j.filters[0].hide-http-response-headers=true
## a regular expression
#bucket4j.filters[0].url=.*
#bucket4j.filters[0].metrics.enabled=true
## (optional) if your not interested in the consumed counter you can specify only the rejected counter
#bucket4j.filters[0].metrics.types=CONSUMED_COUNTER,REJECTED_COUNTER
#bucket4j.filters[0].metrics.tags[0].key=IP
#bucket4j.filters[0].metrics.tags[0].expression=getRemoteAddr()
#bucket4j.filters[0].metrics.tags[0].types=REJECTED_COUNTER
#bucket4j.filters[0].metrics.tags[1].key=URL
#bucket4j.filters[0].metrics.tags[1].expression=getRequestURI()
#bucket4j.filters[0].metrics.tags[2].key=USERNAME
#bucket4j.filters[0].metrics.tags[2].expression=@securityService.username() != null ? @securityService.username() : 'anonym'
## [first, all] if multiple rate limits configured the 'first' strategy stops the processing after the first matching
#bucket4j.filters[0].strategy=first
## if filter-key-type is expression the key can be retrieved by an Spring Expression Language
#bucket4j.filters[0].rate-limits[0].expression=getRemoteAddr()
## an optional SpEl expression to decide to execute the rate limit or not
#bucket4j.filters[0].rate-limits[0].execute-condition=1==1
## an optional SpEl expression to skip the rate limit
#bucket4j.filters[0].rate-limits[0].skip-condition=1==1
#bucket4j.filters[0].rate-limits[0].bandwidths[0].capacity=10
#bucket4j.filters[0].rate-limits[0].bandwidths[0].time=1
#bucket4j.filters[0].rate-limits[0].bandwidths[0].unit=minutes
#bucket4j.filters[0].rate-limits[0].bandwidths[0].fixed-refill-interval=1
#bucket4j.filters[0].rate-limits[0].bandwidths[0].fixed-refill-interval-unit=minutes
## Optional default metric tags for all filters
#bucket4j.default-metric-tags[0].key=IP
#bucket4j.default-metric-tags[0].expression=getRemoteAddr()
#bucket4j.default-metric-tags[0].types=REJECTED_COUNTER
# Hide HTTP response headers